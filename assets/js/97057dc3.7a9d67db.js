"use strict";(self.webpackChunkreact_native_echarts=self.webpackChunkreact_native_echarts||[]).push([[9485],{832:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"react-native-echarts-vs-victory-native-vs-react-native-chart-kit","metadata":{"permalink":"/react-native-echarts/blog/react-native-echarts-vs-victory-native-vs-react-native-chart-kit","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-06-07-react-native-echarts-vs-victory-native-vs-react-native-chart-kit/index.md","source":"@site/blog/2023-06-07-react-native-echarts-vs-victory-native-vs-react-native-chart-kit/index.md","title":"React Native ECharts VS Victory Native VS React Native Chart Kit, Which solution is better?","description":"Introduction: In modern mobile application development, data visualization is a crucial part. Chart libraries play a key role in React Native applications, helping developers present and analyze data in a visual manner. There are many excellent chart libraries available in the React Native ecosystem. In this article, we will compare three popular chart libraries in the React Native community. Let\'s begin this comparative journey to delve into the differences between React Native ECharts, Victory Native, and React Native Chart Kit.","date":"2023-06-07T00:00:00.000Z","formattedDate":"June 7, 2023","tags":[{"label":"website","permalink":"/react-native-echarts/blog/tags/website"}],"readingTime":12.27,"hasTruncateMarker":false,"authors":[{"name":"xuanweiH","title":"Maintainer of react-native-echarts","url":"https://github.com/xuanweiH","imageURL":"https://github.com/xuanweiH.png","key":"xuanwei"}],"frontMatter":{"slug":"react-native-echarts-vs-victory-native-vs-react-native-chart-kit","title":"React Native ECharts VS Victory Native VS React Native Chart Kit, Which solution is better?","authors":["xuanwei"],"tags":["website"]},"nextItem":{"title":"React Native ECharts 1.1 Released !","permalink":"/react-native-echarts/blog/react-native-echarts-1.1-released"}},"content":"![](@site/static/img/react-native-echarts-social-card.png)\\n\\n\\n> Introduction: In modern mobile application development, data visualization is a crucial part. Chart libraries play a key role in React Native applications, helping developers present and analyze data in a visual manner. There are many excellent chart libraries available in the React Native ecosystem. In this article, we will compare three popular chart libraries in the React Native community. Let\'s begin this comparative journey to delve into the differences between React Native ECharts, Victory Native, and React Native Chart Kit.\\n\\n## Chart Library Introduction\\n\\n- **React Native Chart Kit**\\n\\n   [ React Native Chart Kit ](https://github.com/indiespirit/React-native-chart-kit) was developed in 2018, it has been 5 years since its inception. With a cumulative download count of 2,840,757, it has garnered 2.5k+ stars on GitHub. It has become a highly popular library in the React Native community.\\n\\n- **Victory Native**\\n\\n  [ Victory Native ](https://formidable.com/open-source/victory/) is a chart library that was developed in 2015. It has been 7 years since its inception. With a high cumulative download count of 7,434,044, it has garnered an impressive 10.3k+ stars on GitHub. It is the longest-standing and most widely used chart library in the history of React Native.\\n\\n- **React Native ECharts**\\n\\n  [ React Native ECharts ](https://wuba.github.io/react-native-echarts/)is a newly released chart library this year. It currently has 2,565 downloads and has received 363 stars on GitHub. As a rising star among React Native chart libraries, it holds great potential. With time, it is believed that **React Native ECharts** will become one of the most popular chart libraries.\\n\\n  Here is the comparison table for the basic data:\\n\\n\\n  | |  **React Native Chart Kit**   | **Victory Native**  | **React Native ECharts** |\\n  | --- |  :----:  | :----:  | :---: |\\n  | Creation Date | 2018  | 2015 | 2023 |\\n  | Downloads | 2,840,757  | 7,434,044 | 2565 |\\n  | Unpacked Size | 399kB  | 78.4kB  | 169kB  |\\n  | Github star | 2.5k+  | 10.3k+ | 363 |\\n  | Last publish | a year ago  | a month ago | a month ago |\\n\\n## Comparison of Basic Principles\\n\\n- **React Native Chart Kit**\\nThe main approach is to utilize React Native\'s native view components to create the basic structure and layout of the charts, such as View, Text, etc. Additionally, libraries like react-native-svg and paths-js are used for rendering the charts with vector graphics.\\n\\n- **Victory Native**\\n**Victory Native** also relies on React Native\'s native views combined with SVG for rendering. It also draws inspiration from D3 (Data-Driven Documents) by mapping data to chart elements and using scales to transform data values and positions.\\n\\n- **React Native ECharts**\\n**React Native ECharts** fetches the SVG graphic data of ECharts charts and rewrites the SVGPainter of ECharts. By utilizing the existing chart data of ECharts, it renders the charts on the React Native side using either react-native-svg or react-native-skia.\\n\\n\\n\\n## Code Writing Comparison\\n\\nLet\'s take the commonly used area chart as an example. Now, let\'s see how they are implemented using the following code snippets:\\n\\n- **React Native Chart Kit**\\n\\n```js\\nimport { LineChart } from\\"react-native-chart-kit\\";\\nimport { StyleSheet, View, Text } from \'react-native\';\\nconst chartConfig = {\\n    backgroundGradientFrom: \\"#fff\\",\\n    backgroundGradientFromOpacity: 0,\\n    backgroundGradientTo: \\"#fff\\",\\n    backgroundGradientToOpacity: 0.5,\\n    color: (opacity = 1) => `rgba(14, 17, 22, ${opacity})`,\\n    strokeWidth: 2, // optional, default 3\\n    barPercentage: 0.5,\\n    useShadowColorFromDataset: false // optional\\n};\\nexport const LineChart1 = props => {\\n    const data = {\\n        labels: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'],\\n        // labels: props.date,\\n        datasets: [\\n          {\\n            data: [150, 230, 224, 218, 135, 147, 260],\\n            // color: (opacity = 1) => `rgba(134, 65, 244, ${opacity})`, // optional\\n            strokeWidth: 2 // optional\\n          }\\n        ],\\n      };\\n    return (\\n        <View style={styles.container}>\\n            <Text>React Native Chart Kit</Text>\\n            <LineChart\\n                data={data}\\n                width={400}\\n                height={200}\\n                yAxisInterval={1} // \u8bbe\u7f6e y \u8f74\u7684\u95f4\u9694\u503c\u4e3a 1\\n                animate\\n                chartConfig={chartConfig}\\n                withDots={false}\\n            />\\n      </View>\\n    )\\n\\n}\\n\\n```\\n\\n- **Victory Native**\\n\\n```js\\nimport { StyleSheet, View, Text } from \\"react-native\\";\\nimport {\\n  VictoryArea,\\n  VictoryChart,\\n  VictoryLine,\\n  VictoryTheme,\\n  VictoryScatter,\\n} from \\"victory-native\\";\\n\\nexport const LineChart2 = props => {\\n  const data = [\\n      { x: \'Mon\', y: 150 },\\n      { x: \'Tue\', y: 230 },\\n      { x: \'Wed\', y: 224 },\\n      { x: \'Thu\', y: 218 },\\n      { x: \'Fri\', y: 135 },\\n      { x: \'Sat\', y: 147 },\\n      { x: \'sun\', y: 260 },\\n    ];\\n  return (\\n    <View style={styles.container}>\\n      <Text style={styles.title}>Victory Native</Text>\\n      <VictoryChart\\n        theme={VictoryTheme.material}\\n        height={250}\\n        width={400}\\n      >\\n        <VictoryArea\\n          style={{ data: { fill: \\"rgba(230, 231, 231,0.8)\\" } }}\\n          data={data}\\n          animate={{\\n            duration: 2000,\\n            onLoad: { duration: 1000 },\\n          }}\\n        />\\n        <VictoryLine\\n          data={data}\\n          //   interpolation=\\"natural\\" // \u4f7f\u7528\u66f2\u7ebf\u63d2\u503c\u65b9\u6cd5\\n          style={{ data: { stroke: \\"#d6d6d7\\", strokeWidth: 2 } }}\\n        />\\n        <VictoryScatter\\n          data={data}\\n          size={4}\\n          style={{ data: { fill: \\"#24262a\\" } }}\\n        />\\n      </VictoryChart>\\n    </View>\\n  );\\n};\\n\\n```\\n\\n- **React Native ECharts**\\n\\n```js\\nimport { StyleSheet, Text, View } from \'react-native\';\\nimport { useRef, useEffect } from \'react\';\\n/**\\n * \u4e00\u3001\u5f15\u5165echarts\u4f9d\u8d56, \u8fd9\u91cc\u5148\u8bd5\u4e0b\u6298\u7ebf\u56fe\\n */\\nimport * as echarts from \'echarts/core\';\\nimport { LineChart } from \'echarts/charts\';\\nimport { GridComponent } from \'echarts/components\';\\nimport { SVGRenderer, SkiaChart } from \'@wuba/react-native-echarts\';\\necharts.use([SVGRenderer, LineChart, GridComponent]);\\nexport const LineCharts = props => {\\n  const skiaRef = useRef(null); // Ref\u7528\u4e8e\u4fdd\u5b58\u56fe\u8868\u5b9e\u4f8b\\n  useEffect(() => {\\n    /**\\n     * \u56db\u3001\u56fe\u8868\u914d\u7f6e\\n     */\\n    const option = {\\n      xAxis: {\\n        type: \'category\',\\n        data:  [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'],\\n        splitLine: {\\n          show: true,\\n          lineStyle: {\\n            type: \'dashed\',\\n          },}\\n      },\\n      yAxis: {\\n        type: \'value\',\\n        min: \'dataMin\', // \u8bbe\u7f6e y \u8f74\u7684\u6700\u5c0f\u503c\u4e3a\u6570\u636e\u4e2d\u7684\u6700\u5c0f\u503c\\n        splitLine: {\\n          show: true,\\n          lineStyle: {\\n            type: \'dashed\',\\n          },}\\n      },\\n      series: [\\n        {\\n          data: [150, 230, 224, 218, 135, 147, 260],\\n          type: \'line\',\\n          areaStyle: {\\n            color: \'rgba(230, 231, 231,0.8)\'\\n          },\\n          lineStyle: {\\n            color: \'#d6d6d7\'\\n          },\\n          symbol: \'circle\', // \u8bbe\u7f6e\u62d0\u70b9\u7684\u56fe\u5f62\u4e3a\u5706\u5f62\\n          symbolSize: 8, // \u8bbe\u7f6e\u62d0\u70b9\u7684\u5927\u5c0f\\n          itemStyle: {\\n            color: \'#24262a\',\\n          },\\n        },\\n      ],\\n    };\\n    let chart;\\n    if (skiaRef.current) {\\n      /**\\n       * \u4e94\u3001\u521d\u59cb\u5316\u56fe\u8868, \u6307\u5b9a\u4e0b\u5bbd\u9ad8\\n       */\\n      chart = echarts.init(skiaRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width: 400,\\n        height: 300,\\n      });\\n      chart.setOption(option);\\n    }\\n    /**\\n     * \u516d\u3001\u9875\u9762\u5173\u95ed\u540e\u8981\u9500\u6bc1\u56fe\u8868\u5b9e\u4f8b\\n     */\\n    return () => chart?.dispose();\\n  }, []);\\n  return (\\n    <View style={styles.container}>\\n        <Text style={styles.title}>React Native ECharts</Text>\\n        <SkiaChart ref={skiaRef} />\\n    </View>\\n  );\\n}\\n```\\n\\nThe effect is displayed as follows:\\n<img src=\\"https://pic4.58cdn.com.cn/nowater/frs/n_v36a21956e648c4a329da00fb41b166245.png\\"  width=\\"48%\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/a053ec4567fc99f7f75638973d72e26a_tutieshi_288x640_7s.gif\\"  width=\\"48%\\" />\\n\\n\\nFrom a code-writing perspective, **Victory Native** is data-driven, so you typically pass in data and configure related styles through props. Most importantly, it acts more like a set of tools that you can DIY. You can use various components exposed by Victory to customize the charts according to your needs. For example, if you want to add a line and data points to the area chart, you would need to additionally include VictoryLine and VictoryScatter components.\\n\\nReact Native Echarts and **React Native Chart Kit** are similar in usage. Both libraries centralize data and styles within the configuration options. They are more like fully featured tools that allow you to transform the charts by modifying the configurations. Comparatively, the configuration code for **React Native Chart Kit** is simpler, but it may lack some advanced customization options. For example, enabling animation or setting a specific starting value for the y-axis might not be achievable.\\n\\nIn terms of writing code, I personally prefer the configuration-based approach. It is straightforward, easy to grasp, and can improve development efficiency for developers.\\n\\n## Development Experience\\n\\n### Comparison of Rendering Performance \\n\\nWhen it comes to regular charts such as area, bar, and pie charts, all three libraries perform well with small datasets, providing smooth rendering. However, as the data size reaches the order of thousands, noticeable performance differences become apparent. **Victory Native** and **React Native Chart Kit** experience significant lags and, in the case of larger datasets, Victory may even crash. On the other hand, **React Native ECharts** benefits from ECharts\' default data sampling mechanism, which reduces the number of data points when rendering large amounts of data. This helps avoid overcrowding the chart and performance degradation. ECharts automatically samples a relatively small number of data points based on the width of the plotting area and the number of data points, reducing computational and rendering time. Leveraging this mechanism, **React Native ECharts** demonstrates significantly better rendering performance when dealing with large datasets.\\n\\nHere is an example of rendering an area chart using randomly generated 200 data points:\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/7e14bf4b496e5a3ff528096e7ccfd875_590x1087_rn-echart-100-5s.gif\\"  width=\\"200\\" height=\\"300\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/426c93a792c0d35a2f6f86237d099657_590x1087_kit-100_5s.gif\\"  width=\\"200\\" height=\\"300\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/89d063de113ef9602d14b14a48ee1957_590x1087_v-100.gif\\"  width=\\"200\\" height=\\"300\\"  />\\n\\n\\nAs we can see, **React Native ECharts** still maintains relatively good rendering performance. On the other hand, adjustments to data and coordinates are required when using the other two libraries to meet specific business requirements.\\n\\nWhen we increase the test data to 2000 points, **React Native Chart Kit** exhibits noticeable rendering lag, while **Victory Native** throws an error stating Maximum call stack size exceeded. Meanwhile, **React Native ECharts**, benefiting from data sampling, still delivers satisfactory rendering results:\\n<img src=\\"https://pic4.58cdn.com.cn/nowater/frs/n_v37998ba55137a48c5895e18d4c8aae3a8.png\\"  />\\n\\n### Comparison of Chart Variety\\n\\n- **React Native Chart Kit**\\nCurrently, **React Native Chart Kit** supports a relatively limited number of chart types. It mainly covers six specific types of charts, which can fulfill most basic business requirements. However, if there is a need for other types of charts, additional libraries may need to be introduced.\\n\\n    The following image shows most of the chart types that **React Native Chart Kit** can cover, and it can be seen that the variety is relatively limited. \ud83d\ude2d Currently, the developers are continuously maintaining the library and may add more chart types in the future.\\n![\u63cf\u8ff02](https://pic2.58cdn.com.cn/nowater/frs/n_v3de70bac7538d48949b14227bd9bdb28d.png)\\n<font size>(Image source: https://github.com/indiespirit/react-native-chart-kit)</font>\\n\\n- **Victory Native**\\nWhen it comes to chart variety, **Victory Native** offers a greater range compared to **React Native Chart Kit**. However, due to the nature of Victory\'s approach, which involves assembling components to create different types of charts, developers need to have a good understanding of component composition and possess solid coding skills. Additionally, the examples provided on the official Victory website may not be beginner-friendly, as the supported chart instances may not be immediately intuitive. Overall, using **Victory Native** requires a higher level of coding proficiency and logical thinking.\\n\\n    The following image showcases the main components provided by Victory on their official website. It can be observed that there are significantly more options available compared to **React Native Chart Kit**. Moreover, **Victory Native** primarily relies on combining these components, such as points, lines, areas, and axes, to create various types of charts. This allows for a broader range of supported chart types.\\n![\u63cf\u8ff02](https://pic3.58cdn.com.cn/nowater/frs/n_v316dafe8eaf0f435c962933baa233ecdd.png)\\n<font size=\\"2\\">(Image source: https://formidable.com/open-source/victory/docs/)</font>\\n\\n\\n- **React Native ECharts**\\nYou can directly refer to the examples on the ECharts official website, where various types of charts are showcased in a highly intuitive manner. Developers can use the configuration options to customize the charts according to their needs. Currently, **React Native ECharts** supports rendering most of the chart types that ECharts offers.\\n\\n    **React Native ECharts** utilizes the SVG data from ECharts, which means users can render a wide range of different chart types by simply following the examples provided on the ECharts website and configuring their own settings\ud83d\ude0d\\n![\u63cf\u8ff02](https://pic7.58cdn.com.cn/nowater/frs/n_v3d67cc17570b34bf2992455482ce5c494.png)\\n<font size=\\"2\\">(Image source: https://echarts.apache.org/examples/zh/index.html)</font>\\n  The following image showcases some chart types that cannot be easily implemented or require complex combinations using other libraries. However, with **React Native ECharts**, you can effortlessly achieve these charts by referring to the documentation\ud83d\ude80\\n![\u63cf\u8ff02](https://pic6.58cdn.com.cn/nowater/frs/n_v39593dce0b5c745ae8a304e7d337409d7.pic)\\n\\n### Comparison of Guide\\n\\nGetting started with **React Native Chart Kit** primarily involves using the documentation and configuration options provided by the library\'s authors, which can be found on GitHub or npm. By referring to these resources, developers can easily implement chart rendering in their projects.\\n\\n\\nOn the other hand, **Victory Native** has its own [website](https://formidable.com/open-source/victory/docs/), where developers can assemble charts by referring to the provided components and related code in the documentation. However, the website offers a large number of components and elements, making it difficult for developers to quickly find the desired examples. Implementing complex charts often requires developers to think of their own implementation methods, which can lower development efficiency.\\n\\nCompared to **Victory Native** and **React Native Chart Kit**, **React Native ECharts** has several advantages:\\n\\n- Documents\\n\\n    The description provided in the [official documentation](https://wuba.github.io/react-native-echarts/) of **Victory Native** is more clear, comprehensive, and provides ready-to-use examples. Developers can easily understand the library\'s features, configurations, and usage through the documentation. Additionally, there are numerous [usage examples](https://echarts.apache.org/examples/zh/index.html) available on the official ECharts website, which further assists developers in quickly implementing various types of charts.\\n\\n- Online Preview\\n\\n    Just like the ECharts library, **React Native ECharts** provides online preview and testing support. You can directly copy the chart configuration to see how it renders in React Native. [Click here for online preview](https://wuba.github.io/react-native-echarts/zh-Hans/docs/expo-snacks/simple-line-chart)\\n\\n- Multiterminal code\\n\\n    **React Native ECharts** also supports component reuse on the web, enabling cross-platform requirements and achieving code sharing across multiple platforms. It effortlessly achieves code uniformity and ensures consistency of charts across different platforms, thus enhancing our development efficiency.\\n- Support for two rendering modes\\n\\n    **React Native ECharts** supports two rendering modes: Svg and Skia. It is implemented based on react-native-svg and react-native-skia. react-native-skia utilizes the Skia Graphics Library, which is a high-performance graphics rendering engine that provides faster drawing and rendering speeds. It is a boon for developers who want to experience Skia\'s capabilities.\\n\\n### Conclusion\\n  Finally, let\'s compare the performance of these three chart libraries from the following perspectives:\\n\\n\\n  | |  **React Native Chart Kit**   | **Victory Native**  | **React Native ECharts** |\\n  | --- |  :----:  | :----:  | :---: |\\n  | Basic Chart Suitability  | \u2705  | \u2705  | \u2705  |\\n  | Chart Variety | \u2796 | \u2705 | \u2705 |\\n  | Rendering for Large Data | \u2796  | \u2796  | \u2705  |\\n  | Ease of Development | \u2705  | \u2796  | \u2705 |\\n  | Multiterminal code | \u2796  | \u2796 | \u2705 |\\n\\nIt is undeniable that both **Victory Native** and **React Native Chart Kit** are excellent chart libraries for React Native. However, the newly introduced **React Native ECharts** has certain advantages in terms of applicability and ease of entry. Especially in some relatively complex but common charts, such as path charts, radar charts, and candlestick charts, **React Native ECharts** provides examples that allow developers to easily implement them by simply modifying the data in the example code. In these scenarios, **React Native ECharts** is highly recommended as it greatly improves development efficiency. Additionally, for projects with a high demand for various types of charts, the rich collection of chart examples provided by **React Native ECharts** makes it easier for us to handle diverse chart requirements\ud83d\ude01"},{"id":"react-native-echarts-1.1-released","metadata":{"permalink":"/react-native-echarts/blog/react-native-echarts-1.1-released","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-05-29-react-native-echarts-1.1-released/index.md","source":"@site/blog/2023-05-29-react-native-echarts-1.1-released/index.md","title":"React Native ECharts 1.1 Released !","description":"We are excited to release a stable version of React Native ECharts 1.1. In the new version, we have added support for the react-native-gesture-handler gesture solution, among other enhancements. Read on to learn more!","date":"2023-05-29T00:00:00.000Z","formattedDate":"May 29, 2023","tags":[{"label":"website","permalink":"/react-native-echarts/blog/tags/website"}],"readingTime":5.575,"hasTruncateMarker":false,"authors":[{"name":"yechunxi","title":"Maintainer of react-native-echarts","url":"https://github.com/yechunxi","imageURL":"https://github.com/yechunxi.png","key":"yechunxi"}],"frontMatter":{"slug":"react-native-echarts-1.1-released","title":"React Native ECharts 1.1 Released !","authors":["yechunxi"],"tags":["website"]},"prevItem":{"title":"React Native ECharts VS Victory Native VS React Native Chart Kit, Which solution is better?","permalink":"/react-native-echarts/blog/react-native-echarts-vs-victory-native-vs-react-native-chart-kit"},"nextItem":{"title":"React Native Echarts Official Website Has Launched!","permalink":"/react-native-echarts/blog/the-official-website-has-launched"}},"content":"[<img src=\\"https://pic8.58cdn.com.cn/nowater/frs/n_v372f426d05520420e9f009a64822028af.png\\" align=\\"center\\" width=\\"600\\"  />](https://wuba.github.io/react-native-echarts/)\\n\\nWe are excited to release a stable version of React Native ECharts 1.1. In the new version, we have added support for the [react-native-gesture-handler](https://github.com/software-mansion/react-native-gesture-handler) gesture solution, among other enhancements. Read on to learn more!\\n\\n[@wuba/react-native-echarts](https://github.com/wuba/react-native-echarts/), An awesome charting library for React Native, built upon Apache ECharts and leveraging [react-native-svg](https://github.com/software-mansion/react-native-svg) and [react-native-skia](https://github.com/shopify/react-native-skia). Offers significantly better performance compared to WebView-based solutions. If you want to learn more about the project\'s design principles, you can [click here](https://wuba.github.io/react-native-echarts/blog/using-wuba-react-native-echarts).\\n\\n\\nTo provide a more intuitive and accurate understanding of the project\'s features, we have decided to officially rename the initial version `wrn-echarts` to `@wuba/react-native-echarts`. In the new version.\\n\\nThe project source code is available at https://github.com/wuba/react-native-echarts.\\n\\n## Features\\n\\n### Rich Chart Types Supported\\n\\n[@wuba/react-native-echart](https://github.com/wuba/react-native-echarts) is a solution that brings the [ECharts](https://echarts.apache.org/en/index.html) charting library into React Native applications. It utilizes the rendering capabilities of React Native\'s native components, resulting in a significant improvement in rendering speed. It supports a wide range of commonly used chart types, including line charts, area charts, bar charts, and scatter plots, as well as more complex charts such as candlestick charts and heat maps. It can fulfill various visualization requirements in different scenarios.\\n\\nHere are some examples of common chart types:\\n\\n<img src=\\"https://pic4.58cdn.com.cn/nowater/frs/n_v3f0ad5813ae87437c844b785a76fc5d4f.png\\" width=\\"600\\" align=\\"center\\"  />\\n\\nIn addition to the usual chart types, `@wuba/react-native-echart` supports a variety of other graphs, such as tree, heat and K-line charts, with excellent rendering performance.\\n\\n<img src=\\"https://pic6.58cdn.com.cn/nowater/frs/n_v38113ee8d7e384af3875e8083c0e3e4f1.png\\"  width=\\"600\\" />\\n\\nIn addition, we provide comprehensive support for various dynamic charts, and here are some examples. Chart 1 and Chart 2 demonstrate the dynamic changes in per capita income across multiple countries. Chart 1 presents the growth trend of per capita income over the past 70 years, while Chart 2 showcases the dynamic sorting of per capita income for 10 countries in the year 1982. Chart 3 displays a continuously updated speedometer that adapts to changing values over time, and Chart 4 demonstrates a dynamic node addition chart. These charts can dynamically re-render based on evolving data. Regardless of the data update frequency, they consistently deliver outstanding rendering performance.\\n\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/fafab09190a1e94d45d08d392a595798_1684252121615.gif\\"  width=\\"300\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/e538355afcb295c1ad9753d518f31c3a_1684252222255.gif\\"  width=\\"300\\" />\\n\\n`@wuba/react-native-echart` supports a wide range of chart types, but they are too numerous to display here. If you want to explore more comprehensive chart types, you can visit the [taro-playground](https://github.com/wuba/taro-playground) repository to check them out. There, you will find example demos showcasing various ECharts chart types.\\n\\n\\n###  Svg and Skia Supported\\n\\n`@wuba/react-native-echart` supports two rendering modes: Svg and Skia. It is implemented based on `react-native-svg` and `react-native-skia`. How do you choose between the two rendering modes? From the perspective of rendering speed, Svg and Skia have similar performance, as shown in the following figure. However, it\'s important to note that Skia rendering has some limitations in terms of Chinese language support. To display Chinese characters correctly, you need to set up fonts separately. Therefore, when choosing a rendering library, please consider the language requirements of your project and the importance of Chinese language support. We recommend selecting the appropriate rendering mode based on specific circumstances to achieve optimal performance and user experience.\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/cc26413b0283b1bf6627382ec658b405_1684323587137.gif\\" height=\\"300\\" />\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/4ea29ec083262db49fbf4e609dd9af8c_1684300800328.gif\\" height=\\"300\\" />\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/b9f4f9174ab305f92bd05f2fad14f01a_1684301227461.gif\\" height=\\"300\\" />\\n\\n\\n### Support various gestures\\n\\nSupport for various gestures such as tapping, dragging, and scaling is available. By default, we use the built-in PanResponder from React Native to handle these gestures. Starting from version 1.1, we have added support for the `react-native-gesture-handler` library. If you have already integrated this gesture library into your project, we recommend using it directly to handle gestures for enhanced performance and user experience.\\n\\nBelow is a comparison of the two gesture solutions. Judging from the smoothness of chart scrolling, both the default gesture handling and the use of `react-native-gesture-handler` provide excellent fluidity. You can choose the approach that best suits your needs.\\n\\n\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/e82eac73cc429bea39699aaa962ffd4c_1684337433785.gif\\" height=\\"300\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/7126b8247d595689f16a4b905effc929_168433791331.gif\\" height=\\"300\\" />\\n<img src=\\"https://wos2.58cdn.com.cn/DeFazYxWvDti/frsupload/af6a25132f5157d15f936660a9369ec5_16843385448361.gif\\" height=\\"300\\"/>\\n\\n### Web Support\\n\\nWe also support reusing the components of `@wuba/react-native-echart` in the web environment to meet cross-platform requirements and achieve code sharing across multiple platforms. This enables easy code unification, ensures consistency of charts across different platforms, and enhances our development efficiency.\\n\\n[ECharts, the charting library](https://echarts.apache.org/examples/en/index.html#chart-type-line), provides a wide range of online rendering examples for the web. But how well does it perform on React Native? To address this, we offer corresponding online preview and testing support. You can directly copy the chart configuration to see how it renders on React Native. [Online preview click here](https://wuba.github.io/react-native-echarts/docs/expo-snacks/simple-line-chart)\\n\\n## Roadmap\\n\\nDespite our already extensive and well-rounded support for ECharts, we are committed to further optimizing and enhancing it. In our upcoming work, we will focus on improvements and enhancements in the following areas to deliver even more refined functionality. [Click here](https://github.com/orgs/wuba/projects/10) to see more detailed information and progress updates.\\n\\n### Performance Enhancement\\n\\nCompared to the rendering solution using Webview, `@wuba/react-native-echart` has achieved significant improvements in overall rendering performance. However, there is still room for further improvement in rendering speed and memory usage when dealing with large data sets. We are committed to optimizing performance in handling large data sets to ensure exceptional performance and stability in various complex data scenarios.\\n\\n### Known Issue Fixes\\n\\nCurrently, the support for the ECharts charting library is very comprehensive. However, there are still some issues that need to be improved in some chart rendering, such as not supporting map display and incorrect image display in Skia rendering mode. We take these issues very seriously and will continue to work on fixing them. to provide a better chart presentation experience.\\n\\n\\n### ECharts GL Supported\\n\\nWith the widespread application of 3D visualization in various business scenarios, such as the displayed 3D chart below, we will continue to explore and enhance our support for ECharts GL to meet more business needs. You can click [here](https://github.com/orgs/wuba/projects/10) to check the latest progress.\\n\\n<img src=\\"https://pic5.58cdn.com.cn/nowater/frs/n_v320b11894eaa24d36a40713c884eba3a2.png\\"  width=\\"600\\"/>\\n\\n### Improve the Infrastructure\\n\\nIn the future, we will continue to improve the infrastructure by refining test cases, adding user use cases and other content. Standardized test cases can check whether any changes made during the development process have an impact on other functions. We will gradually add more test cases, standardize the code and improve the quality of the code.\\n\\n\\n## Acknowledgments \\n\\nWe are deeply grateful to all our friends in the `@wuba/react-native-echarts` open-source community. Whether you have contributed to the codebase, provided bug reports along with contextual information, or shared ideas to enhance existing features, your contributions have been incredibly valuable to this project. We wholeheartedly welcome you to join us and actively participate in the project\'s discussions and collaborative development.\\n\\nLastly, we would like to express our special thanks to the developers who have contributed to the project\'s success:\\n\\n<img src=\\"https://pic2.58cdn.com.cn/nowater/frs/n_v309c7ce0f3ef34fe4a5e5c1a02f217a2f.png\\" height=\\"40\\"/>"},{"id":"the-official-website-has-launched","metadata":{"permalink":"/react-native-echarts/blog/the-official-website-has-launched","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-03-21-the-official-website-has-launched/index.md","source":"@site/blog/2023-03-21-the-official-website-has-launched/index.md","title":"React Native Echarts Official Website Has Launched!","description":"We\'re excited to announce that the official website for React Native Echarts has launched.!","date":"2023-03-21T00:00:00.000Z","formattedDate":"March 21, 2023","tags":[{"label":"website","permalink":"/react-native-echarts/blog/tags/website"}],"readingTime":5.66,"hasTruncateMarker":true,"authors":[{"name":"Zhiqing Chen","title":"Maintainer of react-native-echarts","url":"https://github.com/zhiqingchen","imageURL":"https://github.com/zhiqingchen.png","key":"zhiqing"}],"frontMatter":{"slug":"the-official-website-has-launched","title":"React Native Echarts Official Website Has Launched!","authors":["zhiqing"],"tags":["website"]},"prevItem":{"title":"React Native ECharts 1.1 Released !","permalink":"/react-native-echarts/blog/react-native-echarts-1.1-released"},"nextItem":{"title":"Using @wuba/react-native-echarts in Expo","permalink":"/react-native-echarts/blog/using-wuba-react-native-echarts"}},"content":"![](@site/static/img/react-native-echarts-social-card.png)\\n\\nWe\'re excited to announce that the official website for React Native Echarts has launched.!\\n\\nWe\'re constantly updating the site to provide you with the latest information about our project. On the website, you will find the complete documentation, edit demos online, and view solutions to common issues and other related information.\\n\\n## New Logo & Design\\n\\n![](@site/static/img/logo-with-title.svg)\\n\\nWe\'ve designed a logo that reflects our project\'s key features: efficiency, simplicity, and technology. The logo is based on a polar coordinate bar chart and has been transformed into a modern and technological style.\\n\\nHope you like it!\\n\x3c!--truncate--\x3e\\n## Building a Modern Document Website for React Native Library\\n\\nIn addition to the website launch information, I will also describe how to build a modern documentation website. If you\'re interested in building a documentation website for your open-source project, this guide can be a great reference.\\n\\n### Initialized with Docusaurus\\n\\n![](https://docusaurus.io/img/slash-introducing.svg)\\n\\nTo build a modern documentation website, the first step is to use [Docusaurus](https://docusaurus.io/) to initialize your project. Docusaurus provides a framework for building documentation websites quickly and easily. You can initialize your project with the following command.\\n\\n```bash\\nnpx create-docusaurus@latest my-website classic --typescript\\n```\\n\\nFor more information, please refer to [Docusaurus Getting Started](https://docusaurus.io/docs/installation).\\n\\n### Ember Expo Snack\\n\\n[Expo Snack](https://snack.expo.dev/) is an open-source platform for running React Native apps in the browser. If you are building a website for a React Native library, this is an excellent feature that helps developers easily try out and test their code without having to download anything locally.\\n\\nIntegrating Snack in a Docusaurus project can be challenging. I refer to this [issue](https://github.com/facebook/docusaurus/issues/3966) and the source code at [react-native-website](https://github.com/facebook/react-native-website).\\n\\nIntegrating Snack involves the following steps.\\n\\n- Write a remarkPlugins call `@react-native-website/remark-snackplayer`. This plugin will visit all `code` nodes with `node.lang == \'SnackPlayer\'` when compiling markdown files, and replace the node with a SnackPlayer `div`.\\n- Write a client module call `snackPlayerInitializer`. This module listens for client-side events and call `initSnackPlayers`, `updateSnacksTheme` at the appropriate time.\\n- Modify the a configuration file `docusaurus.config.js`, add `@react-native-website/remark-snackplayer` to remarkPlugins, add `snackPlayerInitializer` to clientModules, and add `https://snack.expo.dev/embed.js` to `scripts`.\\n- In the `src/css/custom.css` file, define some styles for snack-player.\\n\\nNow you have an online editor, like the one below.\\n\\n```SnackPlayer name=Hello%20World\\nimport { Text } from \'react-native\';\\nexport default function() {\\n  return (\\n    <Text>Hello, world!</Text>\\n  );\\n}\\n```\\n\\nIf you are interested in the implementation principles, you can take a look at our [commit](https://github.com/wuba/react-native-echarts/commit/4ff00c01066b0d7eca7f243e3ac3e07de7dbd902) as well as [Including Snacks in your documentation](https://github.com/expo/snack/blob/main/docs/embedding-snacks.md).\\n\\n### Use a SnackPlayer Component\\n\\nEmber Expo Snack is cool, but sometimes I want to put the code in a tsx file and then import it to the article where I need it. In this way, my code is easier to edit and reusable.\\n\\nIn addition to the online editor, we provide a SnackPlayer component that can be used like below.\\n\\n```tsx\\nimport SnackPlayer from \'@site/src/components/SnackPlayer\';\\nimport SimpleLineChart from \'!!raw-loader!@site/src/snippets/simple-line-chart/index.tsx\';\\n\\n<SnackPlayer name=\\"Simple Line Chart\\">{SimpleLineChart}</SnackPlayer>\\n```\\n\\nThanks to Webpack raw-loader, you can import any code file as raw text, and then insert it in a code block. This component is also very simple to implement, accepting snack-related props and code string, and turning them into SnackPlayer `div`, refer to [this commit](https://github.com/wuba/react-native-echarts/commit/745d5c2d21bc03a42071af4e1da978ec93dbde9e).\\n\\n![](./expo-snacks_simple-line-chart.png)\\n\\nYou can now use @wuba/react-native-echarts online, [try it out now](/docs/expo-snacks/simple-line-chart). We plan to provide more use cases in the future.\\n\\nIf you want to customize your own components, please refer to [Using JSX in Markdown](https://docusaurus.io/docs/markdown-features/react#using-jsx-in-markdown).\\n\\nBy the way, if you just want to have a live editor for react, [React Live](https://docusaurus.io/docs/markdown-features/code-blocks#interactive-code-editor) is a good choice.\\n\\n### Add Doc Search\\n\\nAlgolia is a search engine that can be integrated into your Docusaurus project to provide fast and efficient search functionality for your documentation website. This feature helps users quickly and easily find the information they need.\\n\\nIt\'s easy to integrate Algolia with Docusaurus. You can refer to [Docusaurus Doc Search](https://docusaurus.io/docs/search) for more information.\\n\\n### I18n Support\\n\\nWith the increase of international users, supporting multiple languages is becoming increasingly important. Docusaurus provides i18n support to help you create a website that can be easily translated into different languages.\\n\\nCurrently, we have only added 2 languages, Chinese and English, if you have other needs, please let us know.\\n\\nFor more information, please refer to [Docusaurus i18n](https://docusaurus.io/docs/i18n/introduction).\\n\\n### Show Github Contributes\\n\\nIt\'s always important to give credit where credit is due. Showing the contributors of your project on your documentation website is a great way to acknowledge their hard work and dedication.\\n\\nWe build a [react-native-echart team](https://opencollective.com/react-native-echarts) on https://opencollective.com/ and associate the team with the GitHub repository.\\n\\nYou can then get the contributor images for the project by assembling the following link:\\n```\\nhttps://opencollective.com/react-native-echarts/contributors.svg?button=false\\n```\\n\\nThanks to the following contributors, if you want to join us, please feel free to submit a PR or issue.\\n\\n![](https://opencollective.com/react-native-echarts/contributors.svg?button=false)\\n\\n## Deploying Your Website\\n\\n### Use GitHub Pages to Deploys\\n\\nDeploying your website is an important step in making it accessible to the public. Docusaurus makes it easy to deploy your website using GitHub Pages. This is a fast and efficient way to get your website online quickly.\\n\\nFor more information, please refer to [Docusaurus Deploying to GitHub Pages](https://docusaurus.io/docs/deployment#deploying-to-github-pages).\\n\\n## Increase Website Traffic\\n\\n### Add Global Site Tag for Analytics\\n\\nTo better understand how users interact with our website, we can use Google Analytics to track various metrics such as page views, bounce rates, and user demographics.\\n\\nTo integrate Google Analytics with Docusaurus, you can use the `@docusaurus/plugin-google-gtag` plugin.\\n\\nFor more information, please refer to [Docusaurus Google Analytics](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-google-gtag).\\n\\n### SEO Optimization\\n\\nSearch engine optimization (SEO) is critical for ensuring that your documentation website is easily discoverable by search engines. Docusaurus provides a variety of tools and features that can help you optimize your website for SEO.\\n\\nFor more information, please refer to [Docusaurus SEO](https://docusaurus.io/docs/seo).\\n\\n### Add Sitemap to Google Search Console\\n\\nA sitemap is a file that lists all the pages on our website and helps search engines like Google index our website more efficiently. By adding a sitemap to Google Search Console, we can help Google to discover and index all the pages on our website.\\n\\nDocusaurus comes with a built-in plugin for generating a sitemap. You can get the sitemap by visiting the /sitemap.xml page on your website. Every language has its sitemap, for example:\\n\\n- https://wuba.github.io/react-native-echarts/sitemap.xml\\n- https://wuba.github.io/react-native-echarts/zh-Hans/sitemap.xml\\n\\nFor more information, please refer to [Docusaurus Sitemap](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-sitemap).\\n\\nOnce the sitemap is generated, we can submit it to Google Search Console.\\n\\n## Summary\\n\\nIn this article, we have shown you how to use Docusaurus to build a modern documentation website, as well as how to integrate common features such as online editing, document search, multi-language support, contributor display, and analytics. By following these steps, you can create a robust and user-friendly documentation website for your open-source project.\\n\\nAlso, the source code of our website is located [here](https://github.com/wuba/react-native-echarts/tree/docs)."},{"id":"using-wuba-react-native-echarts","metadata":{"permalink":"/react-native-echarts/blog/using-wuba-react-native-echarts","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-03-10-using-wuba-react-native-echarts/index.md","source":"@site/blog/2023-03-10-using-wuba-react-native-echarts/index.md","title":"Using @wuba/react-native-echarts in Expo","description":"The most used chart library for writing chart-related requirements is echarts. The performance of echarts on the website is quite mature, and the official solution is provided for the applet side, but there is no corresponding support in RN. On the market, most of the search is still based on the essence of the webview implementation, and I prefer the RN-based program, after all, the native experience will be better than the Web.","date":"2023-03-10T00:00:00.000Z","formattedDate":"March 10, 2023","tags":[{"label":"expo","permalink":"/react-native-echarts/blog/tags/expo"}],"readingTime":9.775,"hasTruncateMarker":true,"authors":[{"name":"iambool","title":"Maintainer of react-native-echarts","url":"https://github.com/iambool","imageURL":"https://github.com/iambool.png","key":"iambool"}],"frontMatter":{"slug":"using-wuba-react-native-echarts","title":"Using @wuba/react-native-echarts in Expo","authors":["iambool"],"tags":["expo"]},"prevItem":{"title":"React Native Echarts Official Website Has Launched!","permalink":"/react-native-echarts/blog/the-official-website-has-launched"},"nextItem":{"title":"Using Apache ECharts in React Native","permalink":"/react-native-echarts/blog/using-apache-echarts-in-react-native"}},"content":"The most used chart library for writing chart-related requirements is **echarts**. The performance of echarts on the website is quite mature, and the official solution is provided for the applet side, but there is no corresponding support in RN. On the market, most of the search is still based on the essence of the webview implementation, and I prefer the RN-based program, after all, the native experience will be better than the Web.\\n\\nLater found [**@wuba/react-native-echarts**](https://wuba.github.io/react-native-echarts/) to meet the needs, so try it out, the results are excellent. For those interested in the principle of implementation, click [here](https://wuba.github.io/react-native-echarts/blog/using-apache-echarts-in-react-native)\\n![](./example.png)\\n\\n\x3c!--truncate--\x3e\\n\\n### Tips\\n\\n- If you already have an APP package, you can ignore the previous packaging process and start directly from step 4.\\n- The full code for the trial is on GitHub at: [https://github.com/iambool/TestApp](https://github.com/iambool/TestApp)\\n\\n## The steps to use are as follows\\n\\n### Step 1. Development environment setup\\n\\nThe process of building a local RN development environment is available on the Internet, so I won\'t go over it again. You can search for it on google :)\\n\\n### Step 2. Creating an RN project\\n\\nAs it was a trial, I used the expo to newly initialize an rn project called TestApp.\\n\\n```\\nnpx create-expo-app TestApp\\n```\\n\\n![create TestApp](./create-expo.jpeg)\\n\\n### Step 3. Building an app on mobile devices\\n\\nGenerate ios and android app packages with a command line. iOS is recommended to use the emulator (no need to match the certificate), while Android I was connected to the real machine.\\n\\n```\\nyarn android\\nyarn ios\\n```\\n\\nAfter generating the package, the app like the one below is already installed on the phone, which means it is successful.\\n\\n![picture](./expo-app.png)\\n\\n### Step 4. Install related dependencies\\n\\n```\\nyarn add @wuba/react-native-echarts echarts\\nyarn add @shopify/react-native-skia\\nyarn add react-native-svg\\n```\\n\\n> Note: if you are installing in an existing project, you have to build a new package after the installation is complete, otherwise the lack of native dependencies will report an error.\\n\\n### Step 5. Try the Skia model\\n\\n@wuba/react-native-echarts supports two **rendering modes (Skia and Svg)**, try a simple chart with Skia first. It\'s divided into these small steps\uff1a\\n\\n- Introduce echarts, chart components and other dependencies.\\n- Registering chart components.\\n- Create a chart instance and set an option.\\n- Synchronized destruction of chart instances when the page is destroyed.\\n\\nThe specific code is as follows:\\n\\n```javascript\\nimport { useRef, useEffect } from \'react\';\\nimport { View } from \'react-native\';\\n/**\\n * 1. Import the echarts dependency, this example first tries the line chart\\n */\\nimport * as echarts from \'echarts/core\';\\nimport { LineChart } from \'echarts/charts\';\\nimport { GridComponent } from \'echarts/components\';\\nimport SkiaChart, { SVGRenderer } from \'@wuba/react-native-echarts/skiaChart\';\\n\\n/**\\n * 2. Register the required components\\n * SVGRenderer: it is required to register\\n * LineChart: because we want to show the line chart, we have to import LineChart\\n *      - If you don\'t know which components to import, just look at the error report and add whatever the error says is missing\\n * GridComponent: This is the prompt when the error is reported, and then I added the, ha ha\\n */\\necharts.use([SVGRenderer, LineChart, GridComponent]);\\n\\nexport default () => {\\n  const skiaRef = useRef(null); // Ref for saving chart instances\\n  useEffect(() => {\\n    /**\\n     * 3. chart option\\n     */\\n    const option = {\\n      xAxis: {\\n        type: \'category\',\\n        data: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'],\\n      },\\n      yAxis: {\\n        type: \'value\',\\n      },\\n      series: [\\n        {\\n          data: [150, 230, 224, 218, 135, 147, 260],\\n          type: \'line\',\\n        },\\n      ],\\n    };\\n    let chart;\\n    if (skiaRef.current) {\\n      /**\\n       * 4. Initialize the chart, specifying the lower width and height\\n       */\\n      chart = echarts.init(skiaRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width: 400,\\n        height: 400,\\n      });\\n      chart.setOption(option);\\n    }\\n    /**\\n     * 5. To destroy the chart instance after the page is closed\\n     */\\n    return () => chart?.dispose();\\n  }, []);\\n  return (\\n    <View className=\'index\'>\\n      <SkiaChart ref={skiaRef} />\\n    </View>\\n  );\\n};\\n```\\n\\nAfter writing the code, shaking the phone and reloading the bundle package, an error was reported:\\n\\n> ERROR Invariant Violation: requireNativeComponent: \\"SkiaDomView\\" was not found in the UIManager.\\n\\nI googled it and it says it requires a [version downgrade](https://stackoverflow.com/questions/74648194/shopify-react-native-skia-with-expo). It should correspond to the expo version, there will be a similar prompt when installing the dependency, install the prompted version and it will be fine.\\n![warning](./warning.jpg)\\n\\nSo I followed the instructions and did a version downgrade:\\n\\n```\\n@shopify/react-native-skia@0.1.157\\nreact-native-svg@13.4.0\\n```\\n\\nIt loaded up after rebuilding the app, which was nice. (but Android covers up the point, it seems that the screen width should be adaptive.)\\n\\n| iOS                    | Android                        |\\n| ---------------------- | ------------------------------ |\\n| ![iOS](./skia-ios.png) | ![Android](./skia-android.jpg) |\\n\\n### Step 6. Try the Svg model\\n\\nWrite a more complex dynamic sorting bar chart with Svg mode, and compare Svg and Skia by the way. The full code is [here](https://github.com/iambool/TestApp/blob/main/pages/barRace/index.js)\u3002\\n\\n```javascript\\nimport SvgChart, { SVGRenderer } from \'@wuba/react-native-echarts/svgChart\';\\n// ...Some unimportant code is omitted here\\n\\n// Register the required components, such as BarChart and LegendComponent\\necharts.use([SVGRenderer, BarChart, LegendComponent, GridComponent]);\\n\\nexport default () => {\\n  const skiaRef = useRef(null);\\n  const svgRef = useRef(null);\\n\\n  useEffect(() => {\\n    // Skia mode\\n    const skiaChartData = getData(); // Generate chart bar data\\n    let skiaChart;\\n    let skiaInter;\\n    if (skiaRef.current) {\\n      skiaChart = echarts.init(skiaRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width: 300,\\n        height: 300,\\n      });\\n      skiaChart.setOption(getDefaultOption(skiaChartData));\\n      setTimeout(function () {\\n        run(skiaChart, skiaChartData);\\n      }, 0);\\n      skiaInter = setInterval(function () {\\n        run(skiaChart, skiaChartData);\\n      }, 3000);\\n    }\\n\\n    // Svg mode\\n    const svgChartData = getData();\\n    let svgChart;\\n    let svgInter;\\n    if (svgRef.current) {\\n      svgChart = echarts.init(svgRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width: 300,\\n        height: 300,\\n      });\\n      svgChart.setOption(getDefaultOption(svgChartData));\\n      setTimeout(function () {\\n        run(svgChart, svgChartData);\\n      }, 0);\\n      svgInter = setInterval(function () {\\n        run(svgChart, svgChartData);\\n      }, 3000);\\n    }\\n\\n    return () => {\\n      skiaChart?.dispose();\\n      svgChart?.dispose();\\n      // The timer has to be cleaned up, otherwise it will still run after exiting the page\\n      clearInterval(skiaInter);\\n      clearInterval(svgInter);\\n    };\\n  }, []);\\n  return (\\n    <View>\\n      <Text>skia</Text>\\n      <SkiaChart ref={skiaRef} />\\n      <Text>svg</Text>\\n      <SvgChart ref={svgRef} />\\n    </View>\\n  );\\n};\\n```\\n\\nI can\'t see the difference between these two modes with my eyes.\\n\\n| iOS                                | Android                                |\\n| ---------------------------------- | -------------------------------------- |\\n| ![picture](./dynamic-data-ios.gif) | ![picture](./dynamic-data-android.gif) |\\n\\n### Step 7. Wrapping Chart Components\\n\\nSo far the effect was quite good, but every time I used a bunch of things to import, It bothered me. Let\'s wrap it up simply:\\n\\n```javascript\\nimport { useRef, useEffect } from \'react\';\\nimport * as echarts from \'echarts/core\';\\nimport { BarChart, LineChart, PieChart } from \'echarts/charts\';\\nimport {\\n  DataZoomComponent,\\n  GridComponent,\\n  LegendComponent,\\n  TitleComponent,\\n  ToolboxComponent,\\n  TooltipComponent,\\n} from \'echarts/components\';\\nimport {\\n  SVGRenderer,\\n  SvgChart as _SvgChart,\\n  SkiaChart as _SkiaChart,\\n} from \'@wuba/react-native-echarts\';\\n// Note: If only one of svg or skia is installed, it needs to be imported separately as follows.\\n// import _SkiaChart, { SVGRenderer } from \'@wuba/react-native-echarts/skiaChart\';\\n// import _SvgChart, { SVGRenderer } from \'@wuba/react-native-echarts/svgChart\';\\n\\nimport { Dimensions } from \'react-native\';\\n\\n// Register the required components\\necharts.use([\\n  DataZoomComponent,\\n  SVGRenderer,\\n  BarChart,\\n  GridComponent,\\n  LegendComponent,\\n  ToolboxComponent,\\n  TooltipComponent,\\n  TitleComponent,\\n  PieChart,\\n  LineChart,\\n]);\\n\\n// Default width and height of the chart\\nconst CHART_WIDTH = Dimensions.get(\'screen\').width; // Default with the phone screen width\\nconst CHART_HEIGHT = 300;\\n\\nconst Chart = ({\\n  option,\\n  onInit,\\n  width = CHART_WIDTH,\\n  height = CHART_HEIGHT,\\n  ChartComponent,\\n}) => {\\n  const chartRef = useRef(null);\\n\\n  useEffect(() => {\\n    let chart;\\n    if (chartRef.current) {\\n      chart = echarts.init(chartRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width,\\n        height,\\n      });\\n      option && chart.setOption(option);\\n      onInit?.(chart);\\n    }\\n    return () => chart?.dispose();\\n  }, [option]);\\n  return <ChartComponent ref={chartRef} />;\\n};\\n\\nconst SkiaChart = (props) => <Chart {...props} ChartComponent={_SkiaChart} />;\\nconst SvgChart = (props) => <Chart {...props} ChartComponent={_SvgChart} />;\\n// Just export these two guys\\nexport { SkiaChart, SvgChart };\\n```\\n\\n### Step 8. Using multiple charts\\n\\nOnce it\u2019s wrapped, let\u2019s write a page with multiple charts and see how it works. Here is a page for \u201ce-commerce data analysis\u201d, including a line chart, bar chart and pie chart. Below is the main code written with svg mode, click [here](https://github.com/iambool/TestApp/tree/main/pages/ECdata) for detailed code.\\n\\n```javascript\\nimport { SkiaChart } from \'../../components/Chart\';\\nimport { ScrollView, Text, View } from \'react-native\';\\nimport { StatusBar } from \'expo-status-bar\';\\nimport { useCallback, useEffect, useState } from \'react\';\\nimport {\\n  defaultActual,\\n  lineOption,\\n  salesStatus,\\n  salesVolume,\\n  userAnaly,\\n  getLineData,\\n} from \'./contants\';\\nimport styles from \'./styles\';\\n// Turn on chart loading\\nconst showChartLoading = (chart) =>\\n  chart.showLoading(\'default\', {\\n    maskColor: \'#305d9e\',\\n  });\\n// Close chart loading\\nconst hideChartLoading = (chart) => chart.hideLoading();\\n\\nexport default () => {\\n  const [actual, setActual] = useState(defaultActual); // Recording real-time data\\n\\n  useEffect(() => {\\n    // Assuming a recurring request for data\\n    const interv = setInterval(() => {\\n      const newActual = [];\\n      for (let it of actual) {\\n        newActual.push({\\n          ...it,\\n          num: it.num + Math.floor((Math.random() * it.num) / 100),\\n        });\\n      }\\n      setActual(newActual);\\n    }, 200);\\n    return () => clearInterval(interv);\\n  }, [actual]);\\n\\n  const onInitLineChart = useCallback((myChart) => {\\n    showChartLoading(myChart);\\n    // Simulation of data requests\\n    setTimeout(() => {\\n      myChart.setOption({\\n        series: getLineData,\\n      });\\n      hideChartLoading(myChart);\\n    }, 1000);\\n  }, []);\\n\\n  const onInitUserChart = useCallback((myChart) => {\\n    // Simulate data request, similar to onInitLineChart\\n  }, []);\\n  const onInitSaleChart = useCallback((myChart) => {\\n    // Simulate data request, similar to onInitLineChart\\n  }, []);\\n  const onInitStatusChart = useCallback((myChart) => {\\n    // Simulate data request, similar to onInitLineChart\\n  }, []);\\n\\n  const chartList = [\\n    [\'\u8ba2\u5355\u8d70\u52bf\', lineOption, onInitLineChart],\\n    [\'\u7528\u6237\u7edf\u8ba1\', userAnaly, onInitUserChart],\\n    [\'\u5404\u54c1\u7c7b\u9500\u552e\u7edf\u8ba1\', salesVolume, onInitSaleChart],\\n    [\'\u8ba2\u5355\u72b6\u6001\u7edf\u8ba1\', salesStatus, onInitStatusChart],\\n  ];\\n\\n  return (\\n    <ScrollView style={styles.index}>\\n      <StatusBar style=\'light\' />\\n      <View>\\n        <View style={styles.index_panel_header}>\\n          <Text style={styles.index_panel_title}>\u5b9e\u65f6\u6570\u636e</Text>\\n        </View>\\n        <View style={styles.index_panel_content}>\\n          {actual.map(({ title, num, unit }) => (\\n            <View key={title} style={styles.sale_item}>\\n              <View style={styles.sale_item_cell}>\\n                <Text style={styles.sale_item_text}>{title}</Text>\\n              </View>\\n              <View style={[styles.sale_item_cell, styles.num]}>\\n                <Text style={styles.sale_item_num}>{num}</Text>\\n              </View>\\n              <View style={[styles.sale_item_cell, styles.unit]}>\\n                <Text style={styles.sale_item_text}>{unit}</Text>\\n              </View>\\n            </View>\\n          ))}\\n        </View>\\n      </View>\\n      {chartList.map(([title, data, callback]) => (\\n        <View key={title}>\\n          <View style={styles.index_panel_header}>\\n            <Text style={styles.index_panel_title}>{title}</Text>\\n          </View>\\n          <View style={styles.index_panel_content}>\\n            <SkiaChart option={data} onInit={callback} />\\n          </View>\\n        </View>\\n      ))}\\n    </ScrollView>\\n  );\\n};\\n```\\n\\nReload the bundle and see the result\\n\\n| iOS                          | Android                          |\\n| ---------------------------- | -------------------------------- |\\n| ![picture](./ecdata-ios.gif) | ![picture](./ecdata-android.gif) |\\n\\nAfter rendering, the interaction on iOS is very smooth, while the interaction on Android feels occasionally laggy (not because my phone is too bad, right?...)\\n\\nTry Skia mode again\\n\\n![picture](./skia-chinese.png)\\n\\nWell, although it can, it seems that Chinese can not be displayed properly, Android Chinese is not displayed, and iOS is a mess of code. After reading the documentation, skia currently does not support Chinese on the Android side, We can display Chinese on iOS by setting the font to \u2018PingFang SC\u2019, for example:\\n\\n```javascript\\nconst option = {\\n  title: {\\n    text: \'\u6211\u662f\u4e2d\u6587\',\\n    textStyle: {\\n      fontFamily: \'PingFang SC\', // setting the font type\\n    },\\n  },\\n};\\n```\\n\\nBut every place that displays Chinese has to set the font... that or use Svg first, I\'m lazy.\\n\\n## Summary\\n\\nAfter using it for a while, I summarized the following:\\n\\n- In terms of support, @wuba/react-native-echarts supports all types of charts except GL series and map charts which are not yet supported, which is very enough for daily business. The code to implement the various charts in echarts can be found in [taro-playground](https://github.com/wuba/taro-playground).\\n- Interaction, iOS is very silky smooth, Android sometimes there are cases of frame drops.\\n- Performance: Performance is officially reported as better than other solutions.\\n  - I tried it, not a very large amount of data will not have any problems, but when the amount of data is too large (such as drawing a large amount of data heat map), the rendering speed significantly decreased a lot, which is a point waiting for the official to optimize.\\n  - In addition, if there are many charts on the page, the loading speed will be slow when debugging on the real machine, so it is recommended to use the simulator first.\\n- Chinese support, Svg mode supports Chinese, but Skia mode is not available yet.\\n\\nThe above is only a personal view, any questions welcome communication."},{"id":"using-apache-echarts-in-react-native","metadata":{"permalink":"/react-native-echarts/blog/using-apache-echarts-in-react-native","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-02-09-using-apache-echarts-in-react-native/index.md","source":"@site/blog/2023-02-09-using-apache-echarts-in-react-native/index.md","title":"Using Apache ECharts in React Native","description":"We have developed an open source graphics library for react native APP, which is based on Apache ECharts and uses RNSVG or RNSkia for rendering in a way that is almost identical to using it in the web, and can satisfy most graphics situations. The project source code is available at https://github.com/wuba/react-native-echarts.","date":"2023-02-09T00:00:00.000Z","formattedDate":"February 9, 2023","tags":[{"label":"intro","permalink":"/react-native-echarts/blog/tags/intro"}],"readingTime":6.79,"hasTruncateMarker":true,"authors":[{"name":"Zhiqing Chen","title":"Maintainer of react-native-echarts","url":"https://github.com/zhiqingchen","imageURL":"https://github.com/zhiqingchen.png","key":"zhiqing"}],"frontMatter":{"slug":"using-apache-echarts-in-react-native","title":"Using Apache ECharts in React Native","authors":["zhiqing"],"tags":["intro"]},"prevItem":{"title":"Using @wuba/react-native-echarts in Expo","permalink":"/react-native-echarts/blog/using-wuba-react-native-echarts"},"nextItem":{"title":"Welcome","permalink":"/react-native-echarts/blog/welcome"}},"content":"We have developed an [open source graphics library](https://github.com/wuba/react-native-echarts) for react native APP, which is based on [Apache ECharts](https://github.com/apache/echarts) and uses [RNSVG](https://github.com/react-native-svg/react-native-svg) or [RNSkia](https://github.com/shopify/react-native-skia) for rendering in a way that is almost identical to using it in the web, and can satisfy most graphics situations. The project source code is available at https://github.com/wuba/react-native-echarts.\\n\\n![Examples](./examples.jpg)\\n\x3c!--truncate--\x3e\\n## Introduction\\n\\nWhen drawing charts, the chart library we use most frequently is ECharts. As one of the most mature chart libraries on the market, mainly for web-side use, there is no best way to use it in React Native, in the face of this situation, our solutions are:\\n\\nOption 1, use a chart libraries developed specifically for React Native as an alternative, such as [react-native-charts-wrapper](https://github.com/wuxudong/react-native-charts-wrapper), [victory-native](https://github.com/FormidableLabs/victory/tree/main/packages/victory-native), etc. The style and interaction of these chart libraries are different from ECahrts, and the richness of charts is not enough. Especially in the scenario of multi-platform requirements, a separate UI interaction design is needed for React Native.\\n\\nOption 2, charts are rendered by [react-native-webview](https://github.com/react-native-webview/react-native-webview), This solution uses injectedJavaScript for initialization and postMessage for event response, you can directly use open source libraries such as [react-native-echarts-pro](https://github.com/supervons/react-native-echarts-pro), [native-echarts](https://github.com/somonus/react-native-echarts), etc. When there are multiple charts or too many chart elements on the page, it will encounter performance bottlenecks, such as white screen phenomenon for large data volume area charts and single-axis scatter charts on Android, and there will be more obvious lag and frame drop during rendering.\\n\\nTherefore, we consider developing a new chart library that can integrate the capabilities of ECharts into React Native applications for better usability and stronger performance.\\n\\nSince we don\u2019t want to write a graphics library from scratch, let\u2019s look at what graphics libraries we currently have designed for React Native:\\n\\n1. react-native-svg: provides SVG support to React Native on iOS, Android, macOS, Windows, and a compatibility layer for the web.\\n2. react-native-skia: React Native Skia brings the Skia Graphics Library to React Native. Skia serves as the graphics engine for Google Chrome and Chrome OS, Android, Flutter, Mozilla Firefox and Firefox OS, and many other products. It also provides an [ImageSVG](https://shopify.github.io/react-native-skia/docs/images-svg) component that supports rendering of SVG formatted images.\\n\\nWe know that ECharts supports SVG rendering, so if we get the SVG data before the chart is rendered and provide it to react-native-svg or react-native-skia for rendering, we will be able to achieve our goal.\\n\\nAfter a period of experimentation, we have developed [@wuba/react-native-echart](https://github.com/wuba/react-native-echarts) with the following features\uff1a\\n\\n- \ud83d\udd25 The same way as Apache ECharts\\n- \ud83c\udfa8 Rich charts, covering almost all usage scenarios\\n- \u2728 Optional rendering library, Skia or SVG\\n- \ud83d\ude80 Able to reuse code with web\\n- \ud83d\udcf1 Support for zoom gestures\\n\\n## How to use\\n\\nIn practice, the overall process for @wuba/react-native-echarts is similar to ECharts:\\n\\n1. yarn add @wuba/react-native-echarts\\n2. Choose to install react-native-svg or @shopify/react-native-skia\\n3. Introduce the relevant components from @wuba/react-native-echarts\\n4. Replace the SVGRenderer of ECharts with the SVGRenderer of @wuba/react-native-echarts\\n5. Write the option configuration information for the chart\\n6. Use SkiaChart / SvgChart component\\n\\nHere is the sample code\uff1a\\n\\n```ts\\n// import { SkiaChart, SVGRenderer } from \'@wuba/react-native-echarts\';\\nimport SkiaChart, { SVGRenderer } from \'@wuba/react-native-echarts/skiaChart\';\\nimport * as echarts from \'echarts/core\';\\nimport { useRef, useEffect } from \'react\';\\nimport { LineChart } from \'echarts/charts\';\\n\\necharts.use([ SVGRenderer, LineChart ])\\n\\nexport default function App() {\\n  const skiaRef = useRef<any>(null);\\n  useEffect(() => {\\n    const option = {\\n      xAxis: {\\n        type: \'category\',\\n        data: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\']\\n      },\\n      yAxis: {\\n        type: \'value\'\\n      },\\n      series: [\\n        {\\n          data: [150, 230, 224, 218, 135, 147, 260],\\n          type: \'line\'\\n        }\\n      ]\\n    }\\n    let chart: any;\\n    if (skiaRef.current) {\\n      chart = echarts.init(skiaRef.current, \'light\', {\\n        renderer: \'svg\',\\n        width: 250,\\n        height: 300,\\n      });\\n      chart.setOption(option);\\n    }\\n    return () => chart?.dispose();\\n  }, []);\\n\\n  return <SkiaChart ref={skiaRef} />;\\n}\\n```\\n\\nHere is a screenshot of it:\\n\\n![Screenshot](./screenshot.jpg)\\n\\nIsn\u2019t it particularly easy? More chart configurations can be viewed on the [echarts website](https://echarts.apache.org/examples/en/index.html).\\n\\nWe support most of the charts currently supported by ECharts. I will show some of the charts below, and more examples can be seen on the [taro-playground](https://github.com/wuba/taro-playground) project.\\n\\n![Example](./example.jpg)\\n![Animate1](./animate1.gif)\\n![Animate2](./animate2.gif)\\n![Animate3](./animate3.gif)\\n\\n## Performance\\n\\nAs mentioned before, the mainstream solution for using ECharts in React Native is to implement it via WebView. Among the many WebView-based implementations, react-native-echarts-pro has more users, so we chose react-native-echarts-pro as a comparison.\\n\\nThe following are screenshots of the initialization process for the different implementations:\\n\\n![Performance](./performance.gif)\\n\\nAfter quite a few test cases, we found that @wuba/react-native-echarts has performance advantages in regular usage scenarios, but in scenarios with large amounts of data, there will be significant lag because of the declarative UI rendering method, which we will continue to explore to improve performance subsequently.\\n\\n## Implementation details\\n\\n![Principle](./principle.webp)\\n\\nAbove is the flowchart of the library, taking react-native-svg as an example, the core workflow is:\\n\\n1. Replace the SVGRenderer of ECharts, and replace the registered SVGPainter with the custom SVGPainter.\\n2. CustomSVGPainter inherits from SVGPainter, overwrites the constructor and part of the refresh function, calls the patch function registered on SVGComponent when the chart data is initialized or updated, and passes the calculated new SVG data to it.\\n3. Define SVGComponent, which manages the current chart instance and has a core patch function on it to receive real-time SVG data and then call the SVGElement function.\\n4. SVGElement function iterates all SVG nodes and transforms them into the corresponding SVG elements provided by react-native-svg for the final rendering action.\\n\\nWhen using react-native-skia, there are some differences. There is a core method patchString on the defined SkiaComponent component. patchString receives the changed SVG data, converts it into SVG string, and passes it to the ImageSVG component of react-native-skia for rendering.\\n\\n## Handling TouchEvent\\n\\nECharts events are mouse events, such as click, dblclick, mousedown, mousemove, etc. The mouse events are used to trigger the display or animation of the chart elements.\\n\\nWe use the PanResponder of React Native to capture the events, then simulate the mobile TouchEvent as a mouse event and dispatch it to the chart instance generated by the ECharts init method.\\n\\nFor example, the action of following the mouse to display the legend on the chart is TouchStart + TouchMove on the mobile side, which translates to a mouse event of mousedown + mousemove.\\n\\nAnother example is the zooming of the chart, the mobile side is two-finger zooming, which is translated to the mouse mousewheel event, and the corresponding mousewheel scrolling distance is calculated by the two-finger distance change.\\n\\nHere is the key code:\\n\\n1. Convert TouchEvent to MouseEvent\\n\\n```ts\\nPanResponder.create({\\n  onPanResponderGrant: ({ nativeEvent }) => {\\n    // Action start, translated into mouse down and move events\\n    dispatchEvent(\\n      zrenderId,\\n      [\'mousedown\', \'mousemove\'],\\n      nativeEvent,\\n      \'start\'\\n    );\\n  },\\n  onPanResponderMove: ({ nativeEvent }) => {\\n    // Handling finger movement operations\\n    const length = nativeEvent.touches.length;\\n    if (length === 1) {\\n      // single finger\\n    } else if (length === 2) {\\n      // Handling two-finger movement operations here\\n      if (!zooming) {\\n        // ...\\n      } else {\\n        // Here the event is converted to a scroll wheel\\n        const { initialX, initialY, prevDistance } = pan.current;\\n        const delta = distance - prevDistance;\\n        pan.current.prevDistance = distance;\\n        dispatchEvent(zrenderId, [\'mousewheel\'], nativeEvent, undefined, {\\n          zrX: initialX,\\n          zrY: initialY,\\n          zrDelta: delta / 120,\\n        });\\n      }\\n    }\\n  },\\n  onPanResponderRelease: ({ nativeEvent }) => {\\n    // The action is over, where it is transformed into a mouse click release operation\\n  },\\n})\\n```\\n\\n2. Applying a MouseEvent to an ECharts chart instance\\n\\n```ts\\nfunction dispatchEvent(\\n  zrenderId: number,\\n  types: HandlerName[],\\n  nativeEvent: NativeTouchEvent,\\n  stage: \'start\' | \'end\' | \'change\' | undefined,\\n  props: any = {\\n    zrX: nativeEvent.locationX,\\n    zrY: nativeEvent.locationY,\\n  }\\n) {\\n  if (zrenderId) {\\n    var handler = getInstance(zrenderId).handler;\\n    types.forEach(function (type) {\\n      handler.dispatch(type, {\\n        preventDefault: noop,\\n        stopImmediatePropagation: noop,\\n        stopPropagation: noop,\\n        ...props,\\n      });\\n      stage && handler.processGesture(wrapTouch(nativeEvent), stage);\\n    });\\n  }\\n}\\n```\\n\\n## For more information\\n\\nGo to https://github.com/wuba/react-native-echarts to view the source code, and give us a star if you like it. If you encounter any problems, you can submit an [issue](https://github.com/wuba/react-native-echarts/issues).\\n\\nThe sample code in this post is on the https://github.com/wuba/taro-playground project, which is also open source, and interested parties can also install the new version of the Taro Playground app directly from the app store or from the [releases page](https://github.com/wuba/taro-playground/releases) to experience it."},{"id":"welcome","metadata":{"permalink":"/react-native-echarts/blog/welcome","editUrl":"https://github.com/wuba/react-native-echarts/tree/docs/blog/2023-02-08-welcome/index.md","source":"@site/blog/2023-02-08-welcome/index.md","title":"Welcome","description":"Welcome to react-native-echarts!","date":"2023-02-08T00:00:00.000Z","formattedDate":"February 8, 2023","tags":[{"label":"hello","permalink":"/react-native-echarts/blog/tags/hello"}],"readingTime":0.015,"hasTruncateMarker":false,"authors":[{"name":"Zhiqing Chen","title":"Maintainer of react-native-echarts","url":"https://github.com/zhiqingchen","imageURL":"https://github.com/zhiqingchen.png","key":"zhiqing"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["zhiqing"],"tags":["hello"]},"prevItem":{"title":"Using Apache ECharts in React Native","permalink":"/react-native-echarts/blog/using-apache-echarts-in-react-native"}},"content":"Welcome to react-native-echarts!"}]}')}}]);